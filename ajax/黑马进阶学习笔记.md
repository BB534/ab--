# 黑马进阶记录

##### **各种事件**

`onclick 点击
onblur：失去焦点
onfocus 得到焦点
onkeydown 按键盘
onkeyup 松开键盘
onkepress 按住键盘
onmousedown 按下鼠标
onmouseup 松开鼠标
onmouseover 把鼠标放到上面
ommousemove 移动鼠标
onmouseout 移开鼠标
onload ：页面加载
onchange：改变
onsubmit ：表单提交。`

##### 加载动画
`LottieFiles`

##### ES6类的继承

> super()  //继承父类的方法,但是必须在所有this之前使用

##### ES5构造函数
原型链 ___proto__对象都有原型链
Obj.prototype.方法名 给构造函添加方法 但是this指向改变了,所以需要使用constructor.对象 指回函数

##### 内置对象
数组
	forEach() 遍历数组
	map() 返回一个新的数组，当要遍历的数组中的元素满足提供的条件时就会追加到新的数组中
	fitter() 返回一个新数组,包含通过所有条件的元素
	some() 测试数组中是不是有一个元素通过了条件，返回的是布尔值
	every() 测试一个数组内的所有元素是不是都能通过元素,返回布尔值

字符串
	trim() 去除两边的空白字符
对象
	Object.keys() 类似for in 循环，返回的是属性名组成的数据
	Object.defineProperty(obj,属性名){
		value:设置属性的值
		writable:是否可以重写 true || false
		enumerable:是否可以被枚举 false || true
		configurable:是否可以被删除或修改特性 false || true
	}重新编辑对象
##### 改变函数内部this指向问题
	obj.call(obj,value)
	obj.apply(obj,[]) 两者都会立即调用函数,并且改变this指向
	obj.bind(obj.value) 不会调用函数，改变内部this指向
##### 高级函数
	>定义:传入参数带有函数，或返回参数带有函数就为高级函数
	>例如当我们想某个div移动到指定距离后，执行其他函数，这时就可以传入一个函数来完成剩余的函数
##### 闭包
	>定义:函数,局部变量可以被其他作用域访问即为闭包，用于变量作用域的延伸
例子A：利用闭包的方式得到当前小li的索引号
	for(let i = 0; i < lis.length; i++){
	//利用for循环创建了4个立即执行函数
	//立即执行函数也称为小闭包，因为立即执行函数里面的仁和一个函数都可以使用它的i这个变量
	(function(i){
		lis[i].onclick = function(){
		console.log(i)
		}
	})(i);
	}
例子B:闭包应用-3秒钟滞后于,打印所有li元素的内容
`
	let lis = document.querySelector('.nav').querySelector('li');
	for(let i = 0;i < lis.length; i++){
		(function(i){
			setTimeout(function(){
				console.log(lis[i].innerHTML)
			},3000)
		})(i);
	}
`
> 总结:
> 	1.闭包是什么? 闭包是一个函数(一个作用域内可以访问另外一个函数局部变量的函数)
> 	2.闭包的作用是什么? 延伸变量的作用范围

##### 递归
	>定义:如果一个函数在内部可以调用函数本身,那么这个函数就是递归函数,递归函数得有条件退出。不然就是死循环

##### 深拷贝与浅拷贝
obj.assign() 只拷贝第一次,层次内部则会引用原有内存地址
利用递归来实现深拷贝函数:
	`
	function deepCopy(newobj,obj){
		for(let key in obj){
			let item = obj[key];
			if(item instanceof Array){
				newobj[key] = [];
				deepCopy(newobj[key],item)
			}else if(item instanceof Object){
				newobj[key] = {};
				deepCopy(newobj[key],item)
			}else{
				newobj[key] = item;
			}
		}
	}
	`

##### 正则表达式
创建 let regExp = /123/
检测方法 regExp.test(检测内容) 
限定符 ^ 开头 $ 结尾 精确匹配
字符类 [] 包含,如果加了限定符就是多选1
量词符
*>=0 可以出现0次或者很多次
+>=1 可以出现一次或者很多次
? 1||0 相当于或
{n,n} 区间

量词是设定某个模式出现的次数

[] 多选1
{} 两次符,模式可以重复n次，如果紧接字符，则最后一个重复 如 abc{3} c重复三次
() 优先级 (abc){3} abc重复三次,权重最高

预定义类
\d 匹配0-9 任一数字相当于[0-9]
\D 取反不包含0-9的数字
\w 匹配任意字母、数字、下划线、相当于[A-Za-z0-9]
\W 取反
\s 匹配空格(相当于换行符，制表符，空格符 )[\t\r\n\v\f]
\S 匹配非空格字符串

正则替换
replace(正则表达式/替换字符,字符串)
g：全局匹配
i：忽略大小写
gi：全局匹配忽略大小写

##### 解构赋值
数组解构 [a,b,c] = [1,2,3]；a = 1,b=2,c=3; 一对一
对象解构:{name,age} = {name:'张三',age:18} 
对象解构2: {name:myName,age:myAge} = {name:'张三',age:18}  变量名为myName myAge

##### 箭头函数
ler fn = (参数) => {//函数体} 箭头函数没有this 一边用变量名来赋值;

##### 扩展运算符
1.可以将数组拆分成以逗号分割的参数序列
`
    {
    let ary = ["a","b","b"]
    console.log(...ary)  输出abc
    }
`
2.扩展运算符可以用于合并数组,
`
    {
    let ary1 = [1,2,3]
    let ary2 = [4,5,6]
    let ary3 = [...ary1,...ary2]
    console.log(ary3) 输出[1,2,3,4,5,6]
    }
`
3.ary1. push(...ary2) ； 使用扩展运算符向数组中追加另一个数组
`
    {
    let div = document.getElementsByTagName('div')
    let divAry  = [...div];
    }
`

##### Array的扩展方法 
2.Array[idnex]访问数组元素
3. forEach遍历数组
4. push 添加元素到数组末尾
5. pop删除数组末尾的元素
6. unshift添加元素到数组的头部
7. shift 删除数组头部的元素
8. indeOf 通过某个元素返回数组中的索引
9. splice 从一个人索引位置删除多个元素,传入第三个参数为替换
10.slice 克隆数组 ,传入参数为截取数组
11.数组长度 length
12.from将伪数组，或对象转为数组,就可以调用一些数组的方法
13.isArray() 判断某个变量是否是一个数组对象
13.Array.of() 将一组参数转为数组
14.14.Array.join() 链接所有数组元素转为字符串
15.find() 找到第一个满足条件的元素
`
    let ary = [{id:1,name:'张三'},{id:2,name:'李四'}]
    let target  = ary.find((item,index) => item.id == 2);
`
16.findindex() 用于找到第一个符合条件的数组成员的位置索引，如果没找到放回-1
`
    let ary = [1,5,10,15];
    let index = ary.findindex((value,index) => value > 9)
`
18.includes() 用于查找某个数组中是否包含给定的值返回布尔值
`
    [1,2,3] .includes(2) // true
`

##### String的扩展方法
``  模板字符串 ${}解析变量，并且可以换行，并且可以调用函数，返回函数执行结果
startsWith():判断参数字符串是否在原字符串的头部，返回布尔值
endsWith()：判断参数字符串是否在原字符串的尾部，返回布尔值
repeat() 将字符串重复n次，返回一个新的字符串

##### Set数据结构
类似于数组，但是成员的值都是唯一的，没有重复的值。(可以用来做数组去重)
const s = new Set([1,2,3,4,4]); // 可以接收数组
s.clear() //清空所有值方法
s.add("b"); add方法题添加值 返回set本身
s.delete(1); dlete方法删除值,参数为value
s.has(1); has方法根据value判断值是否存在,返回值true,false
注意：
可以使用forEach方法遍历进行取值
Set方法之间可以使用链式操作 s.add(1).add(2).add(3)
##### Node
exports 对模块成员变量导出
module.exports(obj) 模块成员导出
两者都是导出，但是当内初引用地址指向不同时，最终导出结果已module.exports为准
require 对模块成员导入 

##### Ajax
创建{let xhr = new XMLHttpRequest()}
设置请求方式{xhr.open(方式,url)}
发送请求xhr.send()
接收响应 xhr.onload = function(){
	xhr.responseText //接收返回数据
}
####### get请求参数
let parse = 'name=' + name.value + '&pwd='+pwd.value;
 xhr.open('get','/get?'+parse );
需要自己拼接
###### post请求参数
xhr.setRequestHeader('Content-type','application/x-www-form-urlencoded') 设置请求报文
xhr.send(参数)
###### 请求参数的格式
application/x-www-form-urlencoded
name=zhangsan&age=20&sex=男
2.application/json
{name:'zhangsan',age:'20',sex:'男'}
在传递jsons数据格式时，还要将json对象转换为字符串参数
注意:服务器端需引用body-parser模块,并且设置
bodyParser.json()来解析json
###### Ajax状态码
共有五个
0:请求已经初始化
1.请求建立
2.请求发送
3.响应完成，但只是部分数据
4.响应完成
xhr.readyState 获取ajax状态码
xhr.onreadyStateChange() 监听状态码改变方法
必须用于xhr.send()方法前
###### 错误处理：
xhr.status 获取http状态码
400:返回结果不是预期的结果
404:请求地址不存在
500：服务器端能接收到请求，服务器端返回500状态码
onerror事件网络中断，请求失败
xhr.onerror = function(){
	alert(‘网络错误，请检查’)
}
###### 注意:
IE低版本浏览器下,ajax存在严重的缓存,解决防范为每次请求的url参数不一样即可,所以可以在请求的url后面拼接一个随机参数。
###### 封装Ajax函数
function ajax(options){
            let defules = {
                type:'get',
                url: '',
                headers:{
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                data:{},
                success:function(){},
                error:function(){},
            }
            Object.assign(defules,options);
            let xhr = new XMLHttpRequest();
            let parms = '';
            for (let key in defules.data) {
                parms += key + '=' + defules.data[key] + '&';
            }
            parms = parms.substring(0,parms.length-1);
            if(defules.type == 'get'){
                defules.url = defules.url + '?' + parms;
            }
            xhr.open(defules.type, defules.url);
            if(defules.type == 'post'){
                let contentType = defules.headers['Content-Type'];
                xhr.setRequestHeader('Content-Type', contentType);
                if(contentType == 'application/json'){
                    xhr.send(JSON.stringify(defules.data));
                }else{
                    xhr.send(parms);
                }
            }else{
                xhr.send();
            }
            xhr.onload = function(){
                let responseText = xhr.responseText;
                if(xhr.getResponseHeader('Content-type').includes('application/json')){
                    responseText = JSON.parse(responseText);
                }
                if(xhr.readyState = 4 && xhr.status == 200){
                    defules.success(responseText,xhr)
                }else{
                    defules.error(responseText,xhr)
                }
            }
       }
       ajax({
           type:'post',
           url:'/post',
           data:{name:'zhangsna',age:20},
           headers:{
               'Content-Type':'application/json',
           },
           success:function(data){
               console.log(data);
           },
           error(data,xhr){
               console.log(data);
               console.log(xhr);
           }
       })
###### 三级联动
1.通过接口获取省份信息
2.后去下拉框元素
3.将返回的省份信息显示在下拉框中
4.为下拉框元素添加元素表单值改变事件(onchange)
5.当用户悬着省份时，根据省份id获取城市信息
6.当用户选择城市时，根据城市id获取县城信息
######  模板引擎:
art-template
具体看官网文档,有使用说明
template.defaults.imports：开放模板变量
##### FormData
可以获取指定表单的所有表单，无需添加额外参数，支持异步上传，但是不支持get请求。
let formData = new formData（表单）
获取表单对象中的值
formData.get(name值) // 如果已有会覆盖
formData.set('key','value')
f.append('sex','男') // 追加，并且保留两个值
formData.delete(key)
服务端接收:使用模块(formidable)
const form = new formidable.IncomingForm();
form.parse(req,(err,fields,files)=>{
	res.send(fields);
})

###### 二进制文件上传
file.onchange = function(){
	let form = new FormData();
	form.append('attName',this.files[0]);
 	let xhr = new XMLHttpReuqest();
	xhr.open('post',url);
	xhr.send(form);
}
###### 文件上传进度展示
file.onchange =function(){
	xhr.upload.onprogress = function(ev){
	bar.style.width = (ev.loaded / ev.total) * 100 + '%'
	}
}

##### JSONP代码同源
利用script的请求不同源的性质，动态创建标签设置src为请求地址，后端返回字符串形式的函数,客户端就会解析执行函数,前提是需要在请求的script之前创建全局函数
function jsonp(options){
    let script = document.createElement('script');
    let fnNames = 'myJson' +  			 		  Math.random().toString().replace('.','') + new Date().getTime();
    window[fnNames] = options.success;
    let  parms = '';
    for(let key in options.data){
       parms += '&' + key + '=' +  options.data[key];
    }
    script.src = options.url + '?callback=' + fnNames + parms;
    document.body.appendChild(script);
    script.onload = function(){
        document.body.removeChild(script);
    }
}

##### CORS跨域资源共享 跨域资源共享
在服务端设置响应头header:
允许那些客户端访问:
'Access-Control-Allow-Origin':'*'，
允许客户端的那些请求方式访问:
'Access-Control-Allow-Methods','get,post'
服务端解决方案
利用服务端请求，再把请求结果返回客户端
利用模块 request

##### Cookie：
客户端设置:
withCredentials:true //允许跨域携带cookie
服务端设置:
Access-Control-Allow-Credentials:true //允许客户端请求时携带cookie
##### $.ajax()
type
url
data
contentType
beforeSend://发送请求之前的一些操作
success
error

###### 发送jsonp
$.ajax({
url,
jsonp // 自定义函数名称参数
jsonpCallback //自定义调用的函数
dataType:'jsonp'
success:
})

# Tolist实例

启动